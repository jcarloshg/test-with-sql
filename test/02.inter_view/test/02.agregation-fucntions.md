As a Senior Backend Lead, I categorize aggregation functions not just by "what they do," but by "how they handle edge cases" (like `NULL` values).

Here is the list of the most important aggregation functions you need to master.

---

### 1. The "Big 5" (The Essentials)

Every SQL dialect (Postgres, MySQL, SQL Server) supports these. You will use these 90% of the time.

| Function            | Description                                | Senior "Gotcha" / Nuance                                                                                                           |
| ------------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------- |
| **`COUNT(*)`**      | Counts **total rows**, including `NULL`s.  | Fastest way to count table size.                                                                                                   |
| **`COUNT(column)`** | Counts **non-NULL** values in that column. | If you have 100 rows but only 50 have emails, `COUNT(email)` returns 50.                                                           |
| **`SUM(column)`**   | Adds up numerical values.                  | Ignores `NULL`s. Returns `NULL` (not 0) if the set is empty.                                                                       |
| **`AVG(column)`**   | Calculates the mean average.               | **Critical:** It calculates `SUM / COUNT(column)`. It completely ignores `NULL` rows (they don't count as "0" in the denominator). |
| **`MIN(column)`**   | Finds the lowest value.                    | Works on Strings ("A" < "Z") and Dates too!                                                                                        |
| **`MAX(column)`**   | Finds the highest value.                   | Often used on `created_at` to find the "latest" activity.                                                                          |

---

### 2. Collection Aggregators (The "Developer's Best Friend")

These are vital when you need to flatten "One-to-Many" relationships into a single row (e.g., getting a user and a list of all their tags in one query).

#### **`STRING_AGG` (Postgres) / `GROUP_CONCAT` (MySQL)**

Concatenates strings from a group into a single string with a separator.

- **Use Case:** "Show me the order ID and a comma-separated list of all products in that order."
- **SQL Example:**

```sql
SELECT order_id, STRING_AGG(product_name, ', ') as products
FROM order_items
GROUP BY order_id;
-- Result: 101 | "Apple, Banana, Milk"

```

#### **`ARRAY_AGG` (Postgres specific but powerful)**

Collects values into a native Array. This is superior to `STRING_AGG` if you are using Node.js/TypeScript because `pg` driver converts this directly into a JavaScript Array `[]`.

- **SQL Example:**

```sql
SELECT user_id, ARRAY_AGG(login_ip)
FROM logins
GROUP BY user_id;
-- Result: 55 | ["192.168.1.1", "10.0.0.5"]

```

---

### 3. Boolean Aggregators (Logic Checks)

Useful for "Has this ever happened?" questions without needing complex subqueries.

#### **`BOOL_OR(condition)` (Postgres)**

Returns `TRUE` if **at least one** record in the group matches the condition. (Equivalent to `MAX(CASE WHEN ... THEN 1 ELSE 0 END)` in other DBs).

- **Use Case:** "Did this user have _any_ failed login attempts?"
- **SQL Example:**

```sql
SELECT user_id, BOOL_OR(success = false) as has_failed_login
FROM login_attempts
GROUP BY user_id;

```

#### **`BOOL_AND(condition)`**

Returns `TRUE` only if **all** records in the group match the condition.

---

### 4. Advanced/Statistical (Data Science Lite)

Used mostly for reporting dashboards or anomaly detection.

- **`STDDEV(col)`:** Standard Deviation. Used to find "outliers" (values that are far from the average).
- **`VARIANCE(col)`:** Statistical variance.
- **`PERCENTILE_CONT(0.5)`:** Calculates the **Median**. (Note: `AVG` is mean, this is median. Median is often better for salaries or prices because it ignores extreme outliers).

---

### ðŸ† Senior Interview Question

> **"What is the difference between `COUNT(1)` and `COUNT(column_name)`? Also, why does `AVG(salary)` sometimes give a higher number than expected?"**

**Answer:**

1. `COUNT(1)` (or `COUNT(*)`) counts the **rows** physically present. It doesn't care what's inside them.
2. `COUNT(column_name)` checks the value inside. If the value is `NULL`, it **skips** counting that row.
3. `AVG(salary)` ignores `NULL`s. If you have 2 employees: one earns $100k, the other is `NULL` (unpaid intern).

- **Math:** person = $100,000 average.
- **Reality:** If you wanted to treat the intern as $0, the average should be $50k.
- **Fix:** Use `AVG(COALESCE(salary, 0))`.
